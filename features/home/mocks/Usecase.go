// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	dtos "raihpeduli/features/home/dtos"

	mock "github.com/stretchr/testify/mock"
)

// Usecase is an autogenerated mock type for the Usecase type
type Usecase struct {
	mock.Mock
}

// FindAll provides a mock function with given fields: page, size, personalization
func (_m *Usecase) FindAll(page int, size int, personalization []string) dtos.ResGetHome {
	ret := _m.Called(page, size, personalization)

	var r0 dtos.ResGetHome
	if rf, ok := ret.Get(0).(func(int, int, []string) dtos.ResGetHome); ok {
		r0 = rf(page, size, personalization)
	} else {
		r0 = ret.Get(0).(dtos.ResGetHome)
	}

	return r0
}

// FindAllWeb provides a mock function with given fields: page, size
func (_m *Usecase) FindAllWeb(page int, size int) dtos.ResWebGetHome {
	ret := _m.Called(page, size)

	var r0 dtos.ResWebGetHome
	if rf, ok := ret.Get(0).(func(int, int) dtos.ResWebGetHome); ok {
		r0 = rf(page, size)
	} else {
		r0 = ret.Get(0).(dtos.ResWebGetHome)
	}

	return r0
}

// GetPersonalization provides a mock function with given fields: userID
func (_m *Usecase) GetPersonalization(userID int) []string {
	ret := _m.Called(userID)

	var r0 []string
	if rf, ok := ret.Get(0).(func(int) []string); ok {
		r0 = rf(userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// NewUsecase creates a new instance of Usecase. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewUsecase(t interface {
	mock.TestingT
	Cleanup(func())
}) *Usecase {
	mock := &Usecase{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
